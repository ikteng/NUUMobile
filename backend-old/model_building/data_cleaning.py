import pandas as pdimport DecisionTree as dtimport numpy as npxlPath = "../../UW_Churn_Pred_Data.xls"Frame = pd.read_excel(xlPath)Npa = Frame.to_numpy()clean_data=[]data_expected = []evals=[]PSets = {    'Sale Channel': set(Frame['Sale Channel']),    'Model': set(Frame['Model']),    'Sim Country': set(Frame['Sim Country']),    'Slot 1': set(Frame['Slot 1']),    'Slot 2': set(Frame['Slot 2']),    'Age Range': set(Frame['Age Range']),    }PSets['Sim Country'].remove('uninserted')'''This method takes a set of items and compares each with a specific item, then outputs a list which is 1 where they match and 0 wherethey do notthis is used in parsing for example:    Sale channel set [B2B, 3RD party, B2C NUU] is compared with a value.     If the value is B2B, it outputs [1,0,0]    3RD party [0,1,0] etc    '''def iter_Comp(CompSet, item):    output = []    for comp in CompSet:        output.append(int((comp==item)))    return output'''This loop curates the data from NPA into a new 2d array with a cleaner setup, allowing it to be used with the decision tree code'''for point in Npa:    CleanPoint = []    #chanels    CleanPoint += iter_Comp(PSets['Sale Channel'], point[0])    #models    CleanPoint += iter_Comp(PSets['Model'], point[1])    #under warranty    CleanPoint.append(int(point[2]=="Yes"))    #Sim count    CleanPoint.append(point[11])    #Sim Country     CleanPoint += iter_Comp(PSets['Sim Country'], point[12])    #Slot 1    CleanPoint += iter_Comp(PSets['Slot 1'], point[13])    #Slot 2    CleanPoint += iter_Comp(PSets['Slot 2'], point[14])    #add screen usage as an int    #CleanPoint.append(point[16])    #add bluetooth connections as an int    CleanPoint.append(point[18])    #add wifi as 1/0 if true/false    CleanPoint.append(int(point[19]))    #wallpaper count    CleanPoint.append(int(point[20]))    #Email is set up as 1=true, 2=false, .5=blank    em = point[21]    if (em!=em):        em = .5    #CleanPoint.append(em)    #Last Boot - interval to find run time    CleanPoint.append(point[23])    #age range is the first element of the string converted to an int, this gives a gradient so similar ages are similar scalars    CleanPoint.append(int(point[27][0]))    clean_data.append(CleanPoint)            #this is for evaluating for the real answer, right now the implementation is innmacurate at some times    evals.append(int(point[3]==point[3]))'''Finally we take the clean code and make a decision tree, then test its accuracy'''trainingTup = (clean_data[:2000],evals[:2000])testTup = (clean_data[2000:], evals[2000:])tr = dt.DecisionTree(trainingTup, testTup)            